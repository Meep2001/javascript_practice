/*
    SOURCE: https://javascript.info/dispatch-events

    Built-in event classes form a heirarchy, just like 
    DOM Elements, where the root element is the 
    Event Class
    
    Syntax to create and Event:
        let event = new Event(type[,options])

           type:   string - name of the event could be 
                     built-in or custom
        options: object with 2 optional parameters
            bubbles    - true : the event bubbles
            cancelable - true : default action may be prevented
            by default both are false, without this flag preventDefault wont work
        
    
    dispatchEvent:
        we dispatch the event on an element inorder for it to trigger
        i.e elem.dispatchEvent(event)
        Example in Custom_Events1.html
 
Event.isTrusted:
    flag to tell if the event was triggered from a script or
    from a real user-interaction i.e if click was generated by
    user script or dispatched from script


We can use built-in event classes like UIEvent,MouseEvent,Pointer to create
out custom events, here we can specify addition propeties in
the constructor

ex.
let event = new MouseEvent("click", {
  bubbles: true,
  cancelable: true,
  clientX: 100,
  clientY: 100
});

alert(event.clientX); // 100

CUSTOM EVENTS:
For completely new Event should use CustomEvent(), here
(constructor i.e new CustomEvent(type[,options])) in the second 
argument which is object we add additional field of
detail.
Perhaps here event.type= Custom event

NOTE : event.preventDefault() for CustomEvents

    For new, custom events, there are definitely no default browser actions, 
    but a code that dispatches such event may have its own plans what to do 
    after triggering the event.

    By calling event.preventDefault(), an event handler may send a signal
     that those actions should be canceled.

    In that case the call to elem.dispatchEvent(event) returns false.
     And the code that dispatched it knows that it shouldn’t continue.
    example: prevent_default.html


Events-in-events are synchronous:

Usually events are processed in a queue. That is: if the browser is processing 
onclick and a new event occurs, e.g. mouse moved, then its handling is queued
 up, corresponding mousemove handlers will be called after onclick processing is
  finished.

The notable exception is when one event is initiated from within another 
one, e.g. using dispatchEvent. Such events are processed immediately: the 
new event handlers are called, and then the current event handling is resumed.

For instance, in the code below the menu-open event is triggered during the
 onclick.

It’s processed immediately, without waiting for onclick handler to end.
example: Custom_Events3.html
*/
